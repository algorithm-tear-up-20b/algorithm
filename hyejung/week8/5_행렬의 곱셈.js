/*
[PGS] 행렬의 곱셈 /LV.2 / 99분
*/

/*
채점을 시작합니다.
정확성  테스트
테스트 1 〉	통과 (4.70ms, 37.1MB)
테스트 2 〉	통과 (9.13ms, 38.8MB)
테스트 3 〉	통과 (7.05ms, 39MB)
테스트 4 〉	통과 (0.79ms, 33.8MB)
테스트 5 〉	통과 (4.69ms, 38.8MB)
테스트 6 〉	통과 (3.60ms, 38.4MB)
테스트 7 〉	통과 (1.00ms, 33.7MB)
테스트 8 〉	통과 (0.38ms, 33.7MB)
테스트 9 〉	통과 (0.29ms, 33.6MB)
테스트 10 〉	통과 (8.83ms, 38.6MB)
테스트 11 〉	통과 (3.04ms, 37MB)
테스트 12 〉	통과 (0.58ms, 33.7MB)
테스트 13 〉	통과 (3.93ms, 38.5MB)
테스트 14 〉	통과 (4.92ms, 38.8MB)
테스트 15 〉	통과 (3.47ms, 37.2MB)
테스트 16 〉	통과 (4.54ms, 38.1MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
*/

function solution(arr1, arr2) {
  const answer = [];
  const row = arr1.length;
  const col = arr2[0].length;

  // 각 행을 반복한다.
  for (let i = 0; i < row; i++) {
    // 행에 대한 곱셈 결과가 담길 배열
    const tmp = [];
    // B의 열을 탐색한다
    for (let j = 0; j < col; j++) {
      // 열을 탐색하면서 얻은 값을 합산
      let sum = 0;
      // 열의 각 행을 탐색한다
      for (let k = 0; k < arr2.length; k++) {
        sum += arr1[i][k] * arr2[k][j];
      }
      tmp.push(sum);
    }
    answer.push(tmp);
  }
  return answer;
}

console.log(
  solution(
    [
      [2, 3, 2],
      [4, 2, 4],
      [3, 1, 4],
    ],
    [
      [5, 4, 3],
      [2, 4, 1],
      [3, 1, 1],
    ],
  ),
);

// console.log(
//   solution(
//     [
//       [1, 4],
//       [3, 2],
//       [4, 1],
//     ],
//     [
//       [3, 3],
//       [3, 3],
//     ],
//   ),
// );

/*
[문제]
- 2차원 행렬 arr1, arr2
- arr1 에 arr2를 곱한 결과를 2차원 행렬로 리턴
- -10 <= n <= 20

[행렬의 곱셈?]
- 간단히 요약하면 A의 각 행을 B의 각 열으로 곱해주는 것
- A의 1행의 길이와, B의 1열의 길이는 같다. (곱할 수 있는 배열만 주어지는 조건)
- 대응하는 각 수를 곱해서 전체 값을 더하면 곱셈이 적용된 하나의 열이 완성된다.

[접근 1]
- 2중 loop을 사용해보자.
- i에서 A의 각 열을 탐색, j로 열의 각 요소 및 B의 각 행을 탐색
- i loop 의 스코프에 A[i]의 길이만큼 초기화된 배열 생성
- j로 돌면서 A[i][j] * B[j][j] 값을 임시 배열[j] 위치에 누적 합산...

=> 3번의 반복을 사용해야한다. A의 행 하나가 B의 열의 갯수, 각 열의 요소 갯수만큼 반복되어야 하기 때문에.

- i,j,k 가 있을 때 i로 A의 모든 행을 돈다. 
- j로 B의 각 열을 돈다.
- k로 arr2[k][j] 즉 B의 각 행의 열, 즉 B 배열을 세로로 돌면서 값을 곱한다.
- 곱한 값을 합산하여 A의 다음 행을 탐색하기 전에 배열에 누적시켜준다.
- 다음 행을 탐색하는 시점에 정답 배열에 추가하여 해당 행의 곱셈 결과를 저장한다.

*/

// 메서드를 활용한 다른 풀이
function solution(arr1, arr2) {
  return arr1.map(row =>
    arr2[0].map((x, y) => row.reduce((a, b, c) => a + b * arr2[c][y], 0)),
  );
}
