/*
[PGS] 캐시 /LV.2 / 60분
*/

/*
정확성  테스트
테스트 1 〉	통과 (0.05ms, 33.5MB)
테스트 2 〉	통과 (0.06ms, 33.5MB)
테스트 3 〉	통과 (0.15ms, 33.4MB)
테스트 4 〉	통과 (0.13ms, 33.6MB)
테스트 5 〉	통과 (0.08ms, 33.4MB)
테스트 6 〉	통과 (0.05ms, 33.5MB)
테스트 7 〉	통과 (0.14ms, 33.5MB)
테스트 8 〉	통과 (0.24ms, 33.4MB)
테스트 9 〉	통과 (0.09ms, 33.5MB)
테스트 10 〉	통과 (0.15ms, 33.5MB)
테스트 11 〉	통과 (41.70ms, 41.8MB)
테스트 12 〉	통과 (0.22ms, 33.5MB)
테스트 13 〉	통과 (0.17ms, 33.4MB)
테스트 14 〉	통과 (0.18ms, 33.5MB)
테스트 15 〉	통과 (0.21ms, 33.5MB)
테스트 16 〉	통과 (0.37ms, 33.5MB)
테스트 17 〉	통과 (0.64ms, 33.7MB)
테스트 18 〉	통과 (0.42ms, 33.4MB)
테스트 19 〉	통과 (0.37ms, 33.6MB)
테스트 20 〉	통과 (0.42ms, 33.5MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
*/

function solution(cacheSize, cities) {
  let total = 0;
  const cache = [];

  for (let i = 0; i < cities.length; i++) {
    const city = cities[i].toLowerCase();

    const searchResult = cache.indexOf(city);
    // hit
    if (searchResult !== -1) {
      cache.splice(searchResult, 1);
      total += 1;
    }
    // miss
    else {
      total += 5;
    }
    cache.push(city);
    if (cache.length > cacheSize) cache.shift();
  }
  return total;
}

console.log(
  solution(3, [
    'Jeju',
    'Pangyo',
    'Seoul',
    'NewYork',
    'LA',
    'Jeju',
    'Pangyo',
    'Seoul',
    'NewYork',
    'LA',
  ]),
);

/*
[문제]
- 도시 이름을 검색하면 정보를 찾아주는 서비스가 있다.
- 캐시 크기와 순서대로 처리될 도시 이름이 주어질 때 실행 시간을 구해야함.
- 캐시 교체 알고리즘은 LRU를 사용하며, hit인 경우 1, miss 인 경우 5만큼의 실행시간이 걸린다.

[LRU 알고리즘]
- Least Recently Used : 가장 최근에 사용되지 않은 것
- 캐시에서 작업을 제거할 때 가장 오랫동안 사용하지 않은 것을 제거.

1. cache miss : 작업이 캐시에 없는 상태, 모든 작업이 뒤로 밀리고 새로운 작업이 맨 앞으로 옴
2. cache hit : 작업이 캐시에 있는 상태, 해당 작업이 맨 앞으로 온다.

[접근 1]
1. 캐시 크기만큼 캐시 배열을 생성, 캐시 크기만큼 배열의 앞부분을 자르고, 내용을 캐시에 담는다.
2. 실행시간의 초기값은 5*캐시 크기
3. 캐시를 돌면서 hit 인지 miss 인지 여부를 확인.
- 캐시 배열에 indexOf 로 현재 작업을 검색
- hit인 경우
    - 해당 위치에서 splice하여 요소 삭제
    - 첫 번째 위치로 unshift
    - 실행시간 +1
- miss인 경우
    - 마지막 요소 삭제, 첫 번째 위치로 unshift
    - 실행시간 +1
=> 어떤 경우에서 miss와 hit이 바뀐 것처럼 동작하는듯..?
=> 대소문자 구분을 하지 않아서...!
=> + 처음에 캐시 초기 배열로 설정한 부분 순서가 반대여야한다. 가장 최근에 접근한 부분이 맨 앞으로 오기때문에...

# 7, 11 ~ 15, 17 ~ 20 실패중...

[접근 2]
- 캐시 배열의 사이즈가 cacheSize보다 클 때에만 pop 되도록 해야한다.
=> 아까보다는 통과하는 횟수가 많아졌지만 여전히 틀리고 있다.

- 내가 생각하는 방향은 최신 -> 오래된 순인데, 오래된 순 -> 최신 순 일수도 있는건가..?
=> 방향을 반대로, 즉 최신 요소가 맨 뒤로, 오래된 요소가 가장 첫번째로 오도록 바꿨더니 통과함

- 실제 LRU 알고리즘은 잘 모르겠으나, 방향이 반대가 될 때 즉 새로운 요소의 추가를 push 로 하는게 unshift로 하는 것보단 효율적임.
*/
