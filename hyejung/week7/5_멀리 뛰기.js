/*
[PGS] 멀리 뛰기 /LV.2
통과 여부 : O
*/

function solution(n) {
  // 1) 각 칸에 도달하는 경우의 수를 담고있는 배열 memo
  let memo = new Array(n + 1).fill(0);

  // 1번째 칸부터 n번째 칸까지 반복한다
  for (let i = 1; i <= n; i++) {
    // 첫 번째 칸을 위한 예외처리
    if (!memo[i - 2]) {
      memo[i] = i;
    } else {
      memo[i] = (memo[i - 1] + memo[i - 2]) % 1234567;
    }
  }
  return memo[n];
}

console.log(solution(50));

/*
[문제]
- 한번에 1칸 || 2칸 이동 가능
- 도달해야하는 칸 수 n 이 주어질 때, 이에 도달하는 방법의 경우의 수를 리턴
* 여기에 1234567를 나눈 나머지를 리턴해야함 !! (중요)

[풀이 과정]
* 계단오르기, 돌다리 건너기 같은 *DP* 문제
* DP 란 큰 문제를 작은 문제로 쪼개어 푸는 방법

* 각 칸을 가는 방법은 2칸 전에서 오거나, 1칸 전에서 오거나.
* 각 칸에 도달할 수 있는 경우의 수를 더해 최종적인 경우의 수를 도출할 수 있다.

!! 이해가 잘 안되는 지점
1. !memo[i-2] 즉 2칸 전에 값이 존재하지 않으면 memo[i] = i 가 되는 이유
- 첫 번째 칸 까지 가는 경우를 세기 위한 예외

2. memo[i-1] + memo[i-2] => 1칸 전에서 오는 경우 + 2칸 전에서 오는 경우의 합?
- 1번째 칸을 가기 위해서는 1칸 이동 => 1경우
- 2번째 칸을 가기 위해서는 1 + 1칸 이동 || 2칸 이동 => 2경우
- 3번째 칸을 가기 위해서는 1칸에서 오거나, 2칸에서 오거나.
- 1칸에서 오려면 1칸 + 2칸 => 1경우
- 2칸에서 오려면 1칸 + 1칸 + 1칸 || 2칸 + 1칸 => 2경우
- 총 3가지 경우가 있기 때문에 각 칸까지 오는 경우를 기억하는 memo[i-1] + memo[i-2] 를 더해서 해당 칸에 오는 경우의 수를 합산해나가는 것. 

*/
