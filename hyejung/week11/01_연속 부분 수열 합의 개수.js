/*
[PGS] 연속 부분 수열 합의 개수 /LV.2 / 60분
*/

/*
[문제]
- 자연수로 이루어진 원영 수열의 연속하는 부분 수열의 합으로 만들 수 있는 수의 가지 수
- 원형 수열 : 처음과 끝이 연결된 형태의 수열, 연속하는 부분 수열도 일반 수열보다 많아진다.
- 원형 수열의 모든 원소 elements가 순서대로 주어질 때, 원형 수열 연속 부분수열의 합으로 만들 수 있는 수의 갯수는?

[예제]
[7,9,1,1,4] => 18
- 길이가 1인 연속 부분수열 ~ 1,4,7,9 네 가지 합
- 길이가 2 ~ 2, 5, 10, 11, 16 5가지
- 길이가 3 ~ 6, 11, 12, 17, 20 5가지
- 길이가 4 ~ 13, 15, 18, 21 4가지
- 길이가 5 ~ 22 1가지
=> 여기서 중복되는 값을 제외하면 18가지

[접근]
- 1부터 배열의 길이만큼 반복
- 각 반복마다 i 길이만큼의 연속 부분 수열 구하기
    * 두 개의 포인터 변수 front, rear 두기
    * front와 rear는 같은 인덱스에서 시작
    * rear를 특정 범위만큼 이동시키면서 누적합산. 
    * 다 돌고 rear가 front + 1(??)의 위치로 다시 돌아오게 된다면 부분수열 더하기 멈춤
    * 그런데 누적 합산된 내용을 기억하고 이를 활용할 수 있다면 더 좋을 것 같은데...
- 구한 연속 부분수열을 모두 더하기
- 연속 부분 수열 합을 모아두는 set객체에 추가하기. 
*/

function solution(elements) {
  const set = new Set();
  const N = elements.length;

  // 1 ~ n 길이까지의 연속부분수열을 만들기 위해 전체 길이만큼 반복
  for (let len = 1; len <= N; len++) {
    let rear = 0;
    let sum = 0;

    for (let front = 0; front < N; front++) {
      // 각 반복이 시작되면 윈도우 범위만큼 sum을 만들어둠
      if (front === 0) {
        while (rear < len) {
          sum += elements[rear++];
        }
      }
      // 그 이외의 경우 윈도우 범위에서 하나씩 더하고 빼면서 연속 부분수열의 합을 만든다.
      else {
        // front 이전 값을 뺀다.
        sum -= elements[front - 1];
        // rear가 전체 배열의 끝에 다다르면, 다시 앞으로 돌아간다.(순환)
        if (rear === N) rear = 0;
        // rear 값을 더한다.
        sum += elements[rear++];

        // sum += elements[(j+i-1) % len]; => 나눈 나머지로 rear를 구하는 법도 있음.
      }
      set.add(sum);
    }
  }

  return set.size;
}

console.log(solution([7, 9, 1, 1, 4]));

/*
테스트 1 〉	통과 (0.06ms, 33.5MB)
테스트 2 〉	통과 (5.82ms, 39MB)
테스트 3 〉	통과 (9.86ms, 41.5MB)
테스트 4 〉	통과 (13.72ms, 41.6MB)
테스트 5 〉	통과 (20.23ms, 46.5MB)
테스트 6 〉	통과 (25.17ms, 46.6MB)
테스트 7 〉	통과 (39.38ms, 57MB)
테스트 8 〉	통과 (48.12ms, 56.7MB)
테스트 9 〉	통과 (54.18ms, 57MB)
테스트 10 〉	통과 (55.25ms, 57MB)
테스트 11 〉	통과 (25.65ms, 46.6MB)
테스트 12 〉	통과 (23.87ms, 46.5MB)
테스트 13 〉	통과 (26.86ms, 46.5MB)
테스트 14 〉	통과 (39.29ms, 56.8MB)
테스트 15 〉	통과 (41.64ms, 56.8MB)
테스트 16 〉	통과 (43.97ms, 56.7MB)
테스트 17 〉	통과 (46.61ms, 57.1MB)
테스트 18 〉	통과 (55.87ms, 56.9MB)
테스트 19 〉	통과 (52.31ms, 57.1MB)
테스트 20 〉	통과 (60.63ms, 57.1MB)
*/

// 다른 사람 풀이
function ref(elements) {
  const circular = elements.concat(elements);
  const set = new Set();
  for (let i = 0; i < elements.length; i++) {
    let sum = 0;
    for (let j = 0; j < elements.length; j++) {
      sum += circular[i + j];
      set.add(sum);
    }
  }
  return set.size;
}

/*
테스트 1 〉	통과 (0.04ms, 33.4MB)
테스트 2 〉	통과 (5.37ms, 39.1MB)
테스트 3 〉	통과 (9.40ms, 41.6MB)
테스트 4 〉	통과 (12.77ms, 41.7MB)
테스트 5 〉	통과 (21.91ms, 46.6MB)
테스트 6 〉	통과 (26.96ms, 46.5MB)
테스트 7 〉	통과 (55.62ms, 57.1MB)
테스트 8 〉	통과 (60.38ms, 57MB)
테스트 9 〉	통과 (67.30ms, 57MB)
테스트 10 〉	통과 (73.77ms, 57.1MB)
테스트 11 〉	통과 (23.64ms, 46.5MB)
테스트 12 〉	통과 (32.18ms, 46.6MB)
테스트 13 〉	통과 (35.17ms, 46.5MB)
테스트 14 〉	통과 (50.20ms, 57MB)
테스트 15 〉	통과 (55.76ms, 57MB)
테스트 16 〉	통과 (59.99ms, 57MB)
테스트 17 〉	통과 (57.10ms, 57MB)
테스트 18 〉	통과 (61.80ms, 57MB)
테스트 19 〉	통과 (86.95ms, 57.1MB)
테스트 20 〉	통과 (80.49ms, 57.1MB)
*/
