function solution(land) {
  // 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙
  // DP 문제
  const N = land.length;

  // const dp = Array.from({ length: N }, () => [0, 0, 0, 0]);

  const dp = new Array(N);
  for (let i = 0; i < N; i++) {
    dp[i] = new Array(4).fill(0);
  }

  const row = 4;

  for (let i = 0; i < row; i++) {
    dp[0][i] = land[0][i];
  }

  for (let i = 1; i < N; i++) {
    for (let j = 0; j < row; j++) {
      // j번째 열을 제외한 이전 행에서 선택한 열들의 점수와 j번째 열 다음 열부터 끝까지 열의 점수 중에서 최댓값

      // console.log(dp[i - 1].slice(0, j), dp[i - 1].slice(j + 1), land[i][j]);

      // [] [ 2, 3, 5 ] 5 i=1,j=0
      // [ 1 ] [ 3, 5 ] 6 i=1,j=1
      // [ 1, 2 ] [ 5 ] 7 i=1,j=2
      // [ 1, 2, 3 ] [] 8 i=1,j=3 dp[1][3]을 11
      // [] [ 11, 12, 11 ] 4 i=2,j=0
      // [ 10 ] [ 12, 11 ] 3 i=2,j=1
      // [ 10, 11 ] [ 11 ] 2 i=2,j=2
      // [ 10, 11, 12 ] [] 1 i=2,j=3

      dp[i][j] =
        Math.max(...dp[i - 1].slice(0, j), ...dp[i - 1].slice(j + 1)) +
        land[i][j];
    }
  }
  // 구하는 답은 땅따먹기를 끝냈을 때 최고점
  // 그리고 N을 넣게 되면 index가 초과되기 때문에 N-1을 해줘야 한다.
  return Math.max(...dp[N - 1]);
}

console.log(
  solution([
    [1, 2, 3, 5],
    [5, 6, 7, 8],
    [4, 3, 2, 1],
  ])
);

/*정확성  테스트
테스트 1 〉	통과 (5.24ms, 38.3MB)
테스트 2 〉	통과 (5.47ms, 38.2MB)
테스트 3 〉	통과 (8.09ms, 38.1MB)
테스트 4 〉	통과 (5.47ms, 38.2MB)
테스트 5 〉	통과 (5.51ms, 38.1MB)
테스트 6 〉	통과 (8.72ms, 38.2MB)
테스트 7 〉	통과 (5.50ms, 38.2MB)
테스트 8 〉	통과 (6.02ms, 38.1MB)
테스트 9 〉	통과 (5.46ms, 38.1MB)
테스트 10 〉	통과 (5.41ms, 38MB)
테스트 11 〉	통과 (5.57ms, 37.9MB)
테스트 12 〉	통과 (8.39ms, 38.1MB)
테스트 13 〉	통과 (5.52ms, 38.2MB)
테스트 14 〉	통과 (5.50ms, 38.2MB)
테스트 15 〉	통과 (5.53ms, 38MB)
테스트 16 〉	통과 (5.67ms, 38MB)
테스트 17 〉	통과 (5.55ms, 38.1MB)
테스트 18 〉	통과 (5.58ms, 38MB)

효율성  테스트
테스트 1 〉	통과 (103.21ms, 89.6MB)
테스트 2 〉	통과 (101.67ms, 90.8MB)
테스트 3 〉	통과 (102.82ms, 91.3MB)
테스트 4 〉	통과 (100.96ms, 90.8MB)
채점 결과
정확성: 59.8
효율성: 40.2
합계: 100.0 / 100.0*/
